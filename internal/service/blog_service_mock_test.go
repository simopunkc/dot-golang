// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"dot-golang/internal/abstraction"
	"dot-golang/internal/domain"
	"sync"
)

// Ensure, that BlogCacheMock does implement abstraction.BlogCache.
// If this is not the case, regenerate this file with moq.
var _ abstraction.BlogCache = &BlogCacheMock{}

// BlogCacheMock is a mock implementation of abstraction.BlogCache.
//
//	func TestSomethingThatUsesBlogCache(t *testing.T) {
//
//		// make and configure a mocked abstraction.BlogCache
//		mockedBlogCache := &BlogCacheMock{
//			DelFunc: func(key string) error {
//				panic("mock out the Del method")
//			},
//			ExistsFunc: func(key string) bool {
//				panic("mock out the Exists method")
//			},
//			GetFunc: func(key string) (string, error) {
//				panic("mock out the Get method")
//			},
//			KeysFunc: func(prefixKey string) ([]string, error) {
//				panic("mock out the Keys method")
//			},
//			SetFunc: func(key string, val string) error {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedBlogCache in code that requires abstraction.BlogCache
//		// and then make assertions.
//
//	}
type BlogCacheMock struct {
	// DelFunc mocks the Del method.
	DelFunc func(key string) error

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(key string) bool

	// GetFunc mocks the Get method.
	GetFunc func(key string) (string, error)

	// KeysFunc mocks the Keys method.
	KeysFunc func(prefixKey string) ([]string, error)

	// SetFunc mocks the Set method.
	SetFunc func(key string, val string) error

	// calls tracks calls to the methods.
	calls struct {
		// Del holds details about calls to the Del method.
		Del []struct {
			// Key is the key argument value.
			Key string
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Key is the key argument value.
			Key string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key string
		}
		// Keys holds details about calls to the Keys method.
		Keys []struct {
			// PrefixKey is the prefixKey argument value.
			PrefixKey string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Key is the key argument value.
			Key string
			// Val is the val argument value.
			Val string
		}
	}
	lockDel    sync.RWMutex
	lockExists sync.RWMutex
	lockGet    sync.RWMutex
	lockKeys   sync.RWMutex
	lockSet    sync.RWMutex
}

// Del calls DelFunc.
func (mock *BlogCacheMock) Del(key string) error {
	if mock.DelFunc == nil {
		panic("BlogCacheMock.DelFunc: method is nil but BlogCache.Del was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	mock.lockDel.Unlock()
	return mock.DelFunc(key)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//
//	len(mockedBlogCache.DelCalls())
func (mock *BlogCacheMock) DelCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockDel.RLock()
	calls = mock.calls.Del
	mock.lockDel.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *BlogCacheMock) Exists(key string) bool {
	if mock.ExistsFunc == nil {
		panic("BlogCacheMock.ExistsFunc: method is nil but BlogCache.Exists was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(key)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedBlogCache.ExistsCalls())
func (mock *BlogCacheMock) ExistsCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *BlogCacheMock) Get(key string) (string, error) {
	if mock.GetFunc == nil {
		panic("BlogCacheMock.GetFunc: method is nil but BlogCache.Get was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedBlogCache.GetCalls())
func (mock *BlogCacheMock) GetCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Keys calls KeysFunc.
func (mock *BlogCacheMock) Keys(prefixKey string) ([]string, error) {
	if mock.KeysFunc == nil {
		panic("BlogCacheMock.KeysFunc: method is nil but BlogCache.Keys was just called")
	}
	callInfo := struct {
		PrefixKey string
	}{
		PrefixKey: prefixKey,
	}
	mock.lockKeys.Lock()
	mock.calls.Keys = append(mock.calls.Keys, callInfo)
	mock.lockKeys.Unlock()
	return mock.KeysFunc(prefixKey)
}

// KeysCalls gets all the calls that were made to Keys.
// Check the length with:
//
//	len(mockedBlogCache.KeysCalls())
func (mock *BlogCacheMock) KeysCalls() []struct {
	PrefixKey string
} {
	var calls []struct {
		PrefixKey string
	}
	mock.lockKeys.RLock()
	calls = mock.calls.Keys
	mock.lockKeys.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *BlogCacheMock) Set(key string, val string) error {
	if mock.SetFunc == nil {
		panic("BlogCacheMock.SetFunc: method is nil but BlogCache.Set was just called")
	}
	callInfo := struct {
		Key string
		Val string
	}{
		Key: key,
		Val: val,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(key, val)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedBlogCache.SetCalls())
func (mock *BlogCacheMock) SetCalls() []struct {
	Key string
	Val string
} {
	var calls []struct {
		Key string
		Val string
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// Ensure, that BlogRepositoryMock does implement abstraction.BlogRepository.
// If this is not the case, regenerate this file with moq.
var _ abstraction.BlogRepository = &BlogRepositoryMock{}

// BlogRepositoryMock is a mock implementation of abstraction.BlogRepository.
//
//	func TestSomethingThatUsesBlogRepository(t *testing.T) {
//
//		// make and configure a mocked abstraction.BlogRepository
//		mockedBlogRepository := &BlogRepositoryMock{
//			DeleteRefNewsTopicsFunc: func(refNewsTopics domain.RefNewsTopics) error {
//				panic("mock out the DeleteRefNewsTopics method")
//			},
//			DeleteSingleNewsFunc: func(id int64) error {
//				panic("mock out the DeleteSingleNews method")
//			},
//			GetNewsFunc: func(limit int, offset int) ([]domain.News, error) {
//				panic("mock out the GetNews method")
//			},
//			GetNewsDeletedFunc: func(limit int, offset int) ([]domain.News, error) {
//				panic("mock out the GetNewsDeleted method")
//			},
//			GetNewsDraftedFunc: func(limit int, offset int) ([]domain.News, error) {
//				panic("mock out the GetNewsDrafted method")
//			},
//			GetNewsPublishedFunc: func(limit int, offset int) ([]domain.News, error) {
//				panic("mock out the GetNewsPublished method")
//			},
//			GetSingleNewsFunc: func(id int64) (domain.News, error) {
//				panic("mock out the GetSingleNews method")
//			},
//			GetSingleTopicsFunc: func(id int64) (domain.Topics, error) {
//				panic("mock out the GetSingleTopics method")
//			},
//			GetSingleTopicsNewsFunc: func(idTopic int64, limit int, offset int) ([]domain.News, error) {
//				panic("mock out the GetSingleTopicsNews method")
//			},
//			GetTopicsFunc: func(limit int, offset int) ([]domain.Topics, error) {
//				panic("mock out the GetTopics method")
//			},
//			PatchSingleNewsStatusContentFunc: func(id int64, statusContent domain.StatusContent) error {
//				panic("mock out the PatchSingleNewsStatusContent method")
//			},
//			PatchSingleTopicsCategoryNameFunc: func(idTopic int64, categoryName string) error {
//				panic("mock out the PatchSingleTopicsCategoryName method")
//			},
//			PostNewsFunc: func(new domain.News) error {
//				panic("mock out the PostNews method")
//			},
//			PostRefNewsTopicsFunc: func(refNewsTopics domain.RefNewsTopics) error {
//				panic("mock out the PostRefNewsTopics method")
//			},
//			PostTopicsFunc: func(topics domain.Topics) error {
//				panic("mock out the PostTopics method")
//			},
//			PutSingleNewsFunc: func(new domain.News) error {
//				panic("mock out the PutSingleNews method")
//			},
//		}
//
//		// use mockedBlogRepository in code that requires abstraction.BlogRepository
//		// and then make assertions.
//
//	}
type BlogRepositoryMock struct {
	// DeleteRefNewsTopicsFunc mocks the DeleteRefNewsTopics method.
	DeleteRefNewsTopicsFunc func(refNewsTopics domain.RefNewsTopics) error

	// DeleteSingleNewsFunc mocks the DeleteSingleNews method.
	DeleteSingleNewsFunc func(id int64) error

	// GetNewsFunc mocks the GetNews method.
	GetNewsFunc func(limit int, offset int) ([]domain.News, error)

	// GetNewsDeletedFunc mocks the GetNewsDeleted method.
	GetNewsDeletedFunc func(limit int, offset int) ([]domain.News, error)

	// GetNewsDraftedFunc mocks the GetNewsDrafted method.
	GetNewsDraftedFunc func(limit int, offset int) ([]domain.News, error)

	// GetNewsPublishedFunc mocks the GetNewsPublished method.
	GetNewsPublishedFunc func(limit int, offset int) ([]domain.News, error)

	// GetSingleNewsFunc mocks the GetSingleNews method.
	GetSingleNewsFunc func(id int64) (domain.News, error)

	// GetSingleTopicsFunc mocks the GetSingleTopics method.
	GetSingleTopicsFunc func(id int64) (domain.Topics, error)

	// GetSingleTopicsNewsFunc mocks the GetSingleTopicsNews method.
	GetSingleTopicsNewsFunc func(idTopic int64, limit int, offset int) ([]domain.News, error)

	// GetTopicsFunc mocks the GetTopics method.
	GetTopicsFunc func(limit int, offset int) ([]domain.Topics, error)

	// PatchSingleNewsStatusContentFunc mocks the PatchSingleNewsStatusContent method.
	PatchSingleNewsStatusContentFunc func(id int64, statusContent domain.StatusContent) error

	// PatchSingleTopicsCategoryNameFunc mocks the PatchSingleTopicsCategoryName method.
	PatchSingleTopicsCategoryNameFunc func(idTopic int64, categoryName string) error

	// PostNewsFunc mocks the PostNews method.
	PostNewsFunc func(new domain.News) error

	// PostRefNewsTopicsFunc mocks the PostRefNewsTopics method.
	PostRefNewsTopicsFunc func(refNewsTopics domain.RefNewsTopics) error

	// PostTopicsFunc mocks the PostTopics method.
	PostTopicsFunc func(topics domain.Topics) error

	// PutSingleNewsFunc mocks the PutSingleNews method.
	PutSingleNewsFunc func(new domain.News) error

	// calls tracks calls to the methods.
	calls struct {
		// DeleteRefNewsTopics holds details about calls to the DeleteRefNewsTopics method.
		DeleteRefNewsTopics []struct {
			// RefNewsTopics is the refNewsTopics argument value.
			RefNewsTopics domain.RefNewsTopics
		}
		// DeleteSingleNews holds details about calls to the DeleteSingleNews method.
		DeleteSingleNews []struct {
			// ID is the id argument value.
			ID int64
		}
		// GetNews holds details about calls to the GetNews method.
		GetNews []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetNewsDeleted holds details about calls to the GetNewsDeleted method.
		GetNewsDeleted []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetNewsDrafted holds details about calls to the GetNewsDrafted method.
		GetNewsDrafted []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetNewsPublished holds details about calls to the GetNewsPublished method.
		GetNewsPublished []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetSingleNews holds details about calls to the GetSingleNews method.
		GetSingleNews []struct {
			// ID is the id argument value.
			ID int64
		}
		// GetSingleTopics holds details about calls to the GetSingleTopics method.
		GetSingleTopics []struct {
			// ID is the id argument value.
			ID int64
		}
		// GetSingleTopicsNews holds details about calls to the GetSingleTopicsNews method.
		GetSingleTopicsNews []struct {
			// IdTopic is the idTopic argument value.
			IdTopic int64
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetTopics holds details about calls to the GetTopics method.
		GetTopics []struct {
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// PatchSingleNewsStatusContent holds details about calls to the PatchSingleNewsStatusContent method.
		PatchSingleNewsStatusContent []struct {
			// ID is the id argument value.
			ID int64
			// StatusContent is the statusContent argument value.
			StatusContent domain.StatusContent
		}
		// PatchSingleTopicsCategoryName holds details about calls to the PatchSingleTopicsCategoryName method.
		PatchSingleTopicsCategoryName []struct {
			// IdTopic is the idTopic argument value.
			IdTopic int64
			// CategoryName is the categoryName argument value.
			CategoryName string
		}
		// PostNews holds details about calls to the PostNews method.
		PostNews []struct {
			// New is the new argument value.
			New domain.News
		}
		// PostRefNewsTopics holds details about calls to the PostRefNewsTopics method.
		PostRefNewsTopics []struct {
			// RefNewsTopics is the refNewsTopics argument value.
			RefNewsTopics domain.RefNewsTopics
		}
		// PostTopics holds details about calls to the PostTopics method.
		PostTopics []struct {
			// Topics is the topics argument value.
			Topics domain.Topics
		}
		// PutSingleNews holds details about calls to the PutSingleNews method.
		PutSingleNews []struct {
			// New is the new argument value.
			New domain.News
		}
	}
	lockDeleteRefNewsTopics           sync.RWMutex
	lockDeleteSingleNews              sync.RWMutex
	lockGetNews                       sync.RWMutex
	lockGetNewsDeleted                sync.RWMutex
	lockGetNewsDrafted                sync.RWMutex
	lockGetNewsPublished              sync.RWMutex
	lockGetSingleNews                 sync.RWMutex
	lockGetSingleTopics               sync.RWMutex
	lockGetSingleTopicsNews           sync.RWMutex
	lockGetTopics                     sync.RWMutex
	lockPatchSingleNewsStatusContent  sync.RWMutex
	lockPatchSingleTopicsCategoryName sync.RWMutex
	lockPostNews                      sync.RWMutex
	lockPostRefNewsTopics             sync.RWMutex
	lockPostTopics                    sync.RWMutex
	lockPutSingleNews                 sync.RWMutex
}

// DeleteRefNewsTopics calls DeleteRefNewsTopicsFunc.
func (mock *BlogRepositoryMock) DeleteRefNewsTopics(refNewsTopics domain.RefNewsTopics) error {
	if mock.DeleteRefNewsTopicsFunc == nil {
		panic("BlogRepositoryMock.DeleteRefNewsTopicsFunc: method is nil but BlogRepository.DeleteRefNewsTopics was just called")
	}
	callInfo := struct {
		RefNewsTopics domain.RefNewsTopics
	}{
		RefNewsTopics: refNewsTopics,
	}
	mock.lockDeleteRefNewsTopics.Lock()
	mock.calls.DeleteRefNewsTopics = append(mock.calls.DeleteRefNewsTopics, callInfo)
	mock.lockDeleteRefNewsTopics.Unlock()
	return mock.DeleteRefNewsTopicsFunc(refNewsTopics)
}

// DeleteRefNewsTopicsCalls gets all the calls that were made to DeleteRefNewsTopics.
// Check the length with:
//
//	len(mockedBlogRepository.DeleteRefNewsTopicsCalls())
func (mock *BlogRepositoryMock) DeleteRefNewsTopicsCalls() []struct {
	RefNewsTopics domain.RefNewsTopics
} {
	var calls []struct {
		RefNewsTopics domain.RefNewsTopics
	}
	mock.lockDeleteRefNewsTopics.RLock()
	calls = mock.calls.DeleteRefNewsTopics
	mock.lockDeleteRefNewsTopics.RUnlock()
	return calls
}

// DeleteSingleNews calls DeleteSingleNewsFunc.
func (mock *BlogRepositoryMock) DeleteSingleNews(id int64) error {
	if mock.DeleteSingleNewsFunc == nil {
		panic("BlogRepositoryMock.DeleteSingleNewsFunc: method is nil but BlogRepository.DeleteSingleNews was just called")
	}
	callInfo := struct {
		ID int64
	}{
		ID: id,
	}
	mock.lockDeleteSingleNews.Lock()
	mock.calls.DeleteSingleNews = append(mock.calls.DeleteSingleNews, callInfo)
	mock.lockDeleteSingleNews.Unlock()
	return mock.DeleteSingleNewsFunc(id)
}

// DeleteSingleNewsCalls gets all the calls that were made to DeleteSingleNews.
// Check the length with:
//
//	len(mockedBlogRepository.DeleteSingleNewsCalls())
func (mock *BlogRepositoryMock) DeleteSingleNewsCalls() []struct {
	ID int64
} {
	var calls []struct {
		ID int64
	}
	mock.lockDeleteSingleNews.RLock()
	calls = mock.calls.DeleteSingleNews
	mock.lockDeleteSingleNews.RUnlock()
	return calls
}

// GetNews calls GetNewsFunc.
func (mock *BlogRepositoryMock) GetNews(limit int, offset int) ([]domain.News, error) {
	if mock.GetNewsFunc == nil {
		panic("BlogRepositoryMock.GetNewsFunc: method is nil but BlogRepository.GetNews was just called")
	}
	callInfo := struct {
		Limit  int
		Offset int
	}{
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetNews.Lock()
	mock.calls.GetNews = append(mock.calls.GetNews, callInfo)
	mock.lockGetNews.Unlock()
	return mock.GetNewsFunc(limit, offset)
}

// GetNewsCalls gets all the calls that were made to GetNews.
// Check the length with:
//
//	len(mockedBlogRepository.GetNewsCalls())
func (mock *BlogRepositoryMock) GetNewsCalls() []struct {
	Limit  int
	Offset int
} {
	var calls []struct {
		Limit  int
		Offset int
	}
	mock.lockGetNews.RLock()
	calls = mock.calls.GetNews
	mock.lockGetNews.RUnlock()
	return calls
}

// GetNewsDeleted calls GetNewsDeletedFunc.
func (mock *BlogRepositoryMock) GetNewsDeleted(limit int, offset int) ([]domain.News, error) {
	if mock.GetNewsDeletedFunc == nil {
		panic("BlogRepositoryMock.GetNewsDeletedFunc: method is nil but BlogRepository.GetNewsDeleted was just called")
	}
	callInfo := struct {
		Limit  int
		Offset int
	}{
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetNewsDeleted.Lock()
	mock.calls.GetNewsDeleted = append(mock.calls.GetNewsDeleted, callInfo)
	mock.lockGetNewsDeleted.Unlock()
	return mock.GetNewsDeletedFunc(limit, offset)
}

// GetNewsDeletedCalls gets all the calls that were made to GetNewsDeleted.
// Check the length with:
//
//	len(mockedBlogRepository.GetNewsDeletedCalls())
func (mock *BlogRepositoryMock) GetNewsDeletedCalls() []struct {
	Limit  int
	Offset int
} {
	var calls []struct {
		Limit  int
		Offset int
	}
	mock.lockGetNewsDeleted.RLock()
	calls = mock.calls.GetNewsDeleted
	mock.lockGetNewsDeleted.RUnlock()
	return calls
}

// GetNewsDrafted calls GetNewsDraftedFunc.
func (mock *BlogRepositoryMock) GetNewsDrafted(limit int, offset int) ([]domain.News, error) {
	if mock.GetNewsDraftedFunc == nil {
		panic("BlogRepositoryMock.GetNewsDraftedFunc: method is nil but BlogRepository.GetNewsDrafted was just called")
	}
	callInfo := struct {
		Limit  int
		Offset int
	}{
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetNewsDrafted.Lock()
	mock.calls.GetNewsDrafted = append(mock.calls.GetNewsDrafted, callInfo)
	mock.lockGetNewsDrafted.Unlock()
	return mock.GetNewsDraftedFunc(limit, offset)
}

// GetNewsDraftedCalls gets all the calls that were made to GetNewsDrafted.
// Check the length with:
//
//	len(mockedBlogRepository.GetNewsDraftedCalls())
func (mock *BlogRepositoryMock) GetNewsDraftedCalls() []struct {
	Limit  int
	Offset int
} {
	var calls []struct {
		Limit  int
		Offset int
	}
	mock.lockGetNewsDrafted.RLock()
	calls = mock.calls.GetNewsDrafted
	mock.lockGetNewsDrafted.RUnlock()
	return calls
}

// GetNewsPublished calls GetNewsPublishedFunc.
func (mock *BlogRepositoryMock) GetNewsPublished(limit int, offset int) ([]domain.News, error) {
	if mock.GetNewsPublishedFunc == nil {
		panic("BlogRepositoryMock.GetNewsPublishedFunc: method is nil but BlogRepository.GetNewsPublished was just called")
	}
	callInfo := struct {
		Limit  int
		Offset int
	}{
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetNewsPublished.Lock()
	mock.calls.GetNewsPublished = append(mock.calls.GetNewsPublished, callInfo)
	mock.lockGetNewsPublished.Unlock()
	return mock.GetNewsPublishedFunc(limit, offset)
}

// GetNewsPublishedCalls gets all the calls that were made to GetNewsPublished.
// Check the length with:
//
//	len(mockedBlogRepository.GetNewsPublishedCalls())
func (mock *BlogRepositoryMock) GetNewsPublishedCalls() []struct {
	Limit  int
	Offset int
} {
	var calls []struct {
		Limit  int
		Offset int
	}
	mock.lockGetNewsPublished.RLock()
	calls = mock.calls.GetNewsPublished
	mock.lockGetNewsPublished.RUnlock()
	return calls
}

// GetSingleNews calls GetSingleNewsFunc.
func (mock *BlogRepositoryMock) GetSingleNews(id int64) (domain.News, error) {
	if mock.GetSingleNewsFunc == nil {
		panic("BlogRepositoryMock.GetSingleNewsFunc: method is nil but BlogRepository.GetSingleNews was just called")
	}
	callInfo := struct {
		ID int64
	}{
		ID: id,
	}
	mock.lockGetSingleNews.Lock()
	mock.calls.GetSingleNews = append(mock.calls.GetSingleNews, callInfo)
	mock.lockGetSingleNews.Unlock()
	return mock.GetSingleNewsFunc(id)
}

// GetSingleNewsCalls gets all the calls that were made to GetSingleNews.
// Check the length with:
//
//	len(mockedBlogRepository.GetSingleNewsCalls())
func (mock *BlogRepositoryMock) GetSingleNewsCalls() []struct {
	ID int64
} {
	var calls []struct {
		ID int64
	}
	mock.lockGetSingleNews.RLock()
	calls = mock.calls.GetSingleNews
	mock.lockGetSingleNews.RUnlock()
	return calls
}

// GetSingleTopics calls GetSingleTopicsFunc.
func (mock *BlogRepositoryMock) GetSingleTopics(id int64) (domain.Topics, error) {
	if mock.GetSingleTopicsFunc == nil {
		panic("BlogRepositoryMock.GetSingleTopicsFunc: method is nil but BlogRepository.GetSingleTopics was just called")
	}
	callInfo := struct {
		ID int64
	}{
		ID: id,
	}
	mock.lockGetSingleTopics.Lock()
	mock.calls.GetSingleTopics = append(mock.calls.GetSingleTopics, callInfo)
	mock.lockGetSingleTopics.Unlock()
	return mock.GetSingleTopicsFunc(id)
}

// GetSingleTopicsCalls gets all the calls that were made to GetSingleTopics.
// Check the length with:
//
//	len(mockedBlogRepository.GetSingleTopicsCalls())
func (mock *BlogRepositoryMock) GetSingleTopicsCalls() []struct {
	ID int64
} {
	var calls []struct {
		ID int64
	}
	mock.lockGetSingleTopics.RLock()
	calls = mock.calls.GetSingleTopics
	mock.lockGetSingleTopics.RUnlock()
	return calls
}

// GetSingleTopicsNews calls GetSingleTopicsNewsFunc.
func (mock *BlogRepositoryMock) GetSingleTopicsNews(idTopic int64, limit int, offset int) ([]domain.News, error) {
	if mock.GetSingleTopicsNewsFunc == nil {
		panic("BlogRepositoryMock.GetSingleTopicsNewsFunc: method is nil but BlogRepository.GetSingleTopicsNews was just called")
	}
	callInfo := struct {
		IdTopic int64
		Limit   int
		Offset  int
	}{
		IdTopic: idTopic,
		Limit:   limit,
		Offset:  offset,
	}
	mock.lockGetSingleTopicsNews.Lock()
	mock.calls.GetSingleTopicsNews = append(mock.calls.GetSingleTopicsNews, callInfo)
	mock.lockGetSingleTopicsNews.Unlock()
	return mock.GetSingleTopicsNewsFunc(idTopic, limit, offset)
}

// GetSingleTopicsNewsCalls gets all the calls that were made to GetSingleTopicsNews.
// Check the length with:
//
//	len(mockedBlogRepository.GetSingleTopicsNewsCalls())
func (mock *BlogRepositoryMock) GetSingleTopicsNewsCalls() []struct {
	IdTopic int64
	Limit   int
	Offset  int
} {
	var calls []struct {
		IdTopic int64
		Limit   int
		Offset  int
	}
	mock.lockGetSingleTopicsNews.RLock()
	calls = mock.calls.GetSingleTopicsNews
	mock.lockGetSingleTopicsNews.RUnlock()
	return calls
}

// GetTopics calls GetTopicsFunc.
func (mock *BlogRepositoryMock) GetTopics(limit int, offset int) ([]domain.Topics, error) {
	if mock.GetTopicsFunc == nil {
		panic("BlogRepositoryMock.GetTopicsFunc: method is nil but BlogRepository.GetTopics was just called")
	}
	callInfo := struct {
		Limit  int
		Offset int
	}{
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetTopics.Lock()
	mock.calls.GetTopics = append(mock.calls.GetTopics, callInfo)
	mock.lockGetTopics.Unlock()
	return mock.GetTopicsFunc(limit, offset)
}

// GetTopicsCalls gets all the calls that were made to GetTopics.
// Check the length with:
//
//	len(mockedBlogRepository.GetTopicsCalls())
func (mock *BlogRepositoryMock) GetTopicsCalls() []struct {
	Limit  int
	Offset int
} {
	var calls []struct {
		Limit  int
		Offset int
	}
	mock.lockGetTopics.RLock()
	calls = mock.calls.GetTopics
	mock.lockGetTopics.RUnlock()
	return calls
}

// PatchSingleNewsStatusContent calls PatchSingleNewsStatusContentFunc.
func (mock *BlogRepositoryMock) PatchSingleNewsStatusContent(id int64, statusContent domain.StatusContent) error {
	if mock.PatchSingleNewsStatusContentFunc == nil {
		panic("BlogRepositoryMock.PatchSingleNewsStatusContentFunc: method is nil but BlogRepository.PatchSingleNewsStatusContent was just called")
	}
	callInfo := struct {
		ID            int64
		StatusContent domain.StatusContent
	}{
		ID:            id,
		StatusContent: statusContent,
	}
	mock.lockPatchSingleNewsStatusContent.Lock()
	mock.calls.PatchSingleNewsStatusContent = append(mock.calls.PatchSingleNewsStatusContent, callInfo)
	mock.lockPatchSingleNewsStatusContent.Unlock()
	return mock.PatchSingleNewsStatusContentFunc(id, statusContent)
}

// PatchSingleNewsStatusContentCalls gets all the calls that were made to PatchSingleNewsStatusContent.
// Check the length with:
//
//	len(mockedBlogRepository.PatchSingleNewsStatusContentCalls())
func (mock *BlogRepositoryMock) PatchSingleNewsStatusContentCalls() []struct {
	ID            int64
	StatusContent domain.StatusContent
} {
	var calls []struct {
		ID            int64
		StatusContent domain.StatusContent
	}
	mock.lockPatchSingleNewsStatusContent.RLock()
	calls = mock.calls.PatchSingleNewsStatusContent
	mock.lockPatchSingleNewsStatusContent.RUnlock()
	return calls
}

// PatchSingleTopicsCategoryName calls PatchSingleTopicsCategoryNameFunc.
func (mock *BlogRepositoryMock) PatchSingleTopicsCategoryName(idTopic int64, categoryName string) error {
	if mock.PatchSingleTopicsCategoryNameFunc == nil {
		panic("BlogRepositoryMock.PatchSingleTopicsCategoryNameFunc: method is nil but BlogRepository.PatchSingleTopicsCategoryName was just called")
	}
	callInfo := struct {
		IdTopic      int64
		CategoryName string
	}{
		IdTopic:      idTopic,
		CategoryName: categoryName,
	}
	mock.lockPatchSingleTopicsCategoryName.Lock()
	mock.calls.PatchSingleTopicsCategoryName = append(mock.calls.PatchSingleTopicsCategoryName, callInfo)
	mock.lockPatchSingleTopicsCategoryName.Unlock()
	return mock.PatchSingleTopicsCategoryNameFunc(idTopic, categoryName)
}

// PatchSingleTopicsCategoryNameCalls gets all the calls that were made to PatchSingleTopicsCategoryName.
// Check the length with:
//
//	len(mockedBlogRepository.PatchSingleTopicsCategoryNameCalls())
func (mock *BlogRepositoryMock) PatchSingleTopicsCategoryNameCalls() []struct {
	IdTopic      int64
	CategoryName string
} {
	var calls []struct {
		IdTopic      int64
		CategoryName string
	}
	mock.lockPatchSingleTopicsCategoryName.RLock()
	calls = mock.calls.PatchSingleTopicsCategoryName
	mock.lockPatchSingleTopicsCategoryName.RUnlock()
	return calls
}

// PostNews calls PostNewsFunc.
func (mock *BlogRepositoryMock) PostNews(new domain.News) error {
	if mock.PostNewsFunc == nil {
		panic("BlogRepositoryMock.PostNewsFunc: method is nil but BlogRepository.PostNews was just called")
	}
	callInfo := struct {
		New domain.News
	}{
		New: new,
	}
	mock.lockPostNews.Lock()
	mock.calls.PostNews = append(mock.calls.PostNews, callInfo)
	mock.lockPostNews.Unlock()
	return mock.PostNewsFunc(new)
}

// PostNewsCalls gets all the calls that were made to PostNews.
// Check the length with:
//
//	len(mockedBlogRepository.PostNewsCalls())
func (mock *BlogRepositoryMock) PostNewsCalls() []struct {
	New domain.News
} {
	var calls []struct {
		New domain.News
	}
	mock.lockPostNews.RLock()
	calls = mock.calls.PostNews
	mock.lockPostNews.RUnlock()
	return calls
}

// PostRefNewsTopics calls PostRefNewsTopicsFunc.
func (mock *BlogRepositoryMock) PostRefNewsTopics(refNewsTopics domain.RefNewsTopics) error {
	if mock.PostRefNewsTopicsFunc == nil {
		panic("BlogRepositoryMock.PostRefNewsTopicsFunc: method is nil but BlogRepository.PostRefNewsTopics was just called")
	}
	callInfo := struct {
		RefNewsTopics domain.RefNewsTopics
	}{
		RefNewsTopics: refNewsTopics,
	}
	mock.lockPostRefNewsTopics.Lock()
	mock.calls.PostRefNewsTopics = append(mock.calls.PostRefNewsTopics, callInfo)
	mock.lockPostRefNewsTopics.Unlock()
	return mock.PostRefNewsTopicsFunc(refNewsTopics)
}

// PostRefNewsTopicsCalls gets all the calls that were made to PostRefNewsTopics.
// Check the length with:
//
//	len(mockedBlogRepository.PostRefNewsTopicsCalls())
func (mock *BlogRepositoryMock) PostRefNewsTopicsCalls() []struct {
	RefNewsTopics domain.RefNewsTopics
} {
	var calls []struct {
		RefNewsTopics domain.RefNewsTopics
	}
	mock.lockPostRefNewsTopics.RLock()
	calls = mock.calls.PostRefNewsTopics
	mock.lockPostRefNewsTopics.RUnlock()
	return calls
}

// PostTopics calls PostTopicsFunc.
func (mock *BlogRepositoryMock) PostTopics(topics domain.Topics) error {
	if mock.PostTopicsFunc == nil {
		panic("BlogRepositoryMock.PostTopicsFunc: method is nil but BlogRepository.PostTopics was just called")
	}
	callInfo := struct {
		Topics domain.Topics
	}{
		Topics: topics,
	}
	mock.lockPostTopics.Lock()
	mock.calls.PostTopics = append(mock.calls.PostTopics, callInfo)
	mock.lockPostTopics.Unlock()
	return mock.PostTopicsFunc(topics)
}

// PostTopicsCalls gets all the calls that were made to PostTopics.
// Check the length with:
//
//	len(mockedBlogRepository.PostTopicsCalls())
func (mock *BlogRepositoryMock) PostTopicsCalls() []struct {
	Topics domain.Topics
} {
	var calls []struct {
		Topics domain.Topics
	}
	mock.lockPostTopics.RLock()
	calls = mock.calls.PostTopics
	mock.lockPostTopics.RUnlock()
	return calls
}

// PutSingleNews calls PutSingleNewsFunc.
func (mock *BlogRepositoryMock) PutSingleNews(new domain.News) error {
	if mock.PutSingleNewsFunc == nil {
		panic("BlogRepositoryMock.PutSingleNewsFunc: method is nil but BlogRepository.PutSingleNews was just called")
	}
	callInfo := struct {
		New domain.News
	}{
		New: new,
	}
	mock.lockPutSingleNews.Lock()
	mock.calls.PutSingleNews = append(mock.calls.PutSingleNews, callInfo)
	mock.lockPutSingleNews.Unlock()
	return mock.PutSingleNewsFunc(new)
}

// PutSingleNewsCalls gets all the calls that were made to PutSingleNews.
// Check the length with:
//
//	len(mockedBlogRepository.PutSingleNewsCalls())
func (mock *BlogRepositoryMock) PutSingleNewsCalls() []struct {
	New domain.News
} {
	var calls []struct {
		New domain.News
	}
	mock.lockPutSingleNews.RLock()
	calls = mock.calls.PutSingleNews
	mock.lockPutSingleNews.RUnlock()
	return calls
}

// Ensure, that BlogEventMock does implement abstraction.BlogEvent.
// If this is not the case, regenerate this file with moq.
var _ abstraction.BlogEvent = &BlogEventMock{}

// BlogEventMock is a mock implementation of abstraction.BlogEvent.
//
//	func TestSomethingThatUsesBlogEvent(t *testing.T) {
//
//		// make and configure a mocked abstraction.BlogEvent
//		mockedBlogEvent := &BlogEventMock{
//			PostNewsFunc: func(new domain.News)  {
//				panic("mock out the PostNews method")
//			},
//		}
//
//		// use mockedBlogEvent in code that requires abstraction.BlogEvent
//		// and then make assertions.
//
//	}
type BlogEventMock struct {
	// PostNewsFunc mocks the PostNews method.
	PostNewsFunc func(new domain.News)

	// calls tracks calls to the methods.
	calls struct {
		// PostNews holds details about calls to the PostNews method.
		PostNews []struct {
			// New is the new argument value.
			New domain.News
		}
	}
	lockPostNews sync.RWMutex
}

// PostNews calls PostNewsFunc.
func (mock *BlogEventMock) PostNews(new domain.News) {
	if mock.PostNewsFunc == nil {
		panic("BlogEventMock.PostNewsFunc: method is nil but BlogEvent.PostNews was just called")
	}
	callInfo := struct {
		New domain.News
	}{
		New: new,
	}
	mock.lockPostNews.Lock()
	mock.calls.PostNews = append(mock.calls.PostNews, callInfo)
	mock.lockPostNews.Unlock()
	mock.PostNewsFunc(new)
}

// PostNewsCalls gets all the calls that were made to PostNews.
// Check the length with:
//
//	len(mockedBlogEvent.PostNewsCalls())
func (mock *BlogEventMock) PostNewsCalls() []struct {
	New domain.News
} {
	var calls []struct {
		New domain.News
	}
	mock.lockPostNews.RLock()
	calls = mock.calls.PostNews
	mock.lockPostNews.RUnlock()
	return calls
}

// Ensure, that BlogUtilMock does implement abstraction.BlogUtil.
// If this is not the case, regenerate this file with moq.
var _ abstraction.BlogUtil = &BlogUtilMock{}

// BlogUtilMock is a mock implementation of abstraction.BlogUtil.
//
//	func TestSomethingThatUsesBlogUtil(t *testing.T) {
//
//		// make and configure a mocked abstraction.BlogUtil
//		mockedBlogUtil := &BlogUtilMock{
//			ByteToStrFunc: func(raw []byte) string {
//				panic("mock out the ByteToStr method")
//			},
//			GetLimitAndOffsetFunc: func(page int) (int, int) {
//				panic("mock out the GetLimitAndOffset method")
//			},
//			Int64ToStringFunc: func(raw int64) string {
//				panic("mock out the Int64ToString method")
//			},
//			IntToStringFunc: func(raw int) string {
//				panic("mock out the IntToString method")
//			},
//			StringToArrayNewsFunc: func(jsonStr string) []domain.News {
//				panic("mock out the StringToArrayNews method")
//			},
//			StringToArrayTopicsFunc: func(jsonStr string) []domain.Topics {
//				panic("mock out the StringToArrayTopics method")
//			},
//			StringToIntFunc: func(raw string) (int, error) {
//				panic("mock out the StringToInt method")
//			},
//			StringToInt64Func: func(raw string) (int64, error) {
//				panic("mock out the StringToInt64 method")
//			},
//			StringToNewsFunc: func(jsonStr string) domain.News {
//				panic("mock out the StringToNews method")
//			},
//			StringToTopicsFunc: func(jsonStr string) domain.Topics {
//				panic("mock out the StringToTopics method")
//			},
//			ToJsonFunc: func(raw interface{}) []byte {
//				panic("mock out the ToJson method")
//			},
//		}
//
//		// use mockedBlogUtil in code that requires abstraction.BlogUtil
//		// and then make assertions.
//
//	}
type BlogUtilMock struct {
	// ByteToStrFunc mocks the ByteToStr method.
	ByteToStrFunc func(raw []byte) string

	// GetLimitAndOffsetFunc mocks the GetLimitAndOffset method.
	GetLimitAndOffsetFunc func(page int) (int, int)

	// Int64ToStringFunc mocks the Int64ToString method.
	Int64ToStringFunc func(raw int64) string

	// IntToStringFunc mocks the IntToString method.
	IntToStringFunc func(raw int) string

	// StringToArrayNewsFunc mocks the StringToArrayNews method.
	StringToArrayNewsFunc func(jsonStr string) []domain.News

	// StringToArrayTopicsFunc mocks the StringToArrayTopics method.
	StringToArrayTopicsFunc func(jsonStr string) []domain.Topics

	// StringToIntFunc mocks the StringToInt method.
	StringToIntFunc func(raw string) (int, error)

	// StringToInt64Func mocks the StringToInt64 method.
	StringToInt64Func func(raw string) (int64, error)

	// StringToNewsFunc mocks the StringToNews method.
	StringToNewsFunc func(jsonStr string) domain.News

	// StringToTopicsFunc mocks the StringToTopics method.
	StringToTopicsFunc func(jsonStr string) domain.Topics

	// ToJsonFunc mocks the ToJson method.
	ToJsonFunc func(raw interface{}) []byte

	// calls tracks calls to the methods.
	calls struct {
		// ByteToStr holds details about calls to the ByteToStr method.
		ByteToStr []struct {
			// Raw is the raw argument value.
			Raw []byte
		}
		// GetLimitAndOffset holds details about calls to the GetLimitAndOffset method.
		GetLimitAndOffset []struct {
			// Page is the page argument value.
			Page int
		}
		// Int64ToString holds details about calls to the Int64ToString method.
		Int64ToString []struct {
			// Raw is the raw argument value.
			Raw int64
		}
		// IntToString holds details about calls to the IntToString method.
		IntToString []struct {
			// Raw is the raw argument value.
			Raw int
		}
		// StringToArrayNews holds details about calls to the StringToArrayNews method.
		StringToArrayNews []struct {
			// JsonStr is the jsonStr argument value.
			JsonStr string
		}
		// StringToArrayTopics holds details about calls to the StringToArrayTopics method.
		StringToArrayTopics []struct {
			// JsonStr is the jsonStr argument value.
			JsonStr string
		}
		// StringToInt holds details about calls to the StringToInt method.
		StringToInt []struct {
			// Raw is the raw argument value.
			Raw string
		}
		// StringToInt64 holds details about calls to the StringToInt64 method.
		StringToInt64 []struct {
			// Raw is the raw argument value.
			Raw string
		}
		// StringToNews holds details about calls to the StringToNews method.
		StringToNews []struct {
			// JsonStr is the jsonStr argument value.
			JsonStr string
		}
		// StringToTopics holds details about calls to the StringToTopics method.
		StringToTopics []struct {
			// JsonStr is the jsonStr argument value.
			JsonStr string
		}
		// ToJson holds details about calls to the ToJson method.
		ToJson []struct {
			// Raw is the raw argument value.
			Raw interface{}
		}
	}
	lockByteToStr           sync.RWMutex
	lockGetLimitAndOffset   sync.RWMutex
	lockInt64ToString       sync.RWMutex
	lockIntToString         sync.RWMutex
	lockStringToArrayNews   sync.RWMutex
	lockStringToArrayTopics sync.RWMutex
	lockStringToInt         sync.RWMutex
	lockStringToInt64       sync.RWMutex
	lockStringToNews        sync.RWMutex
	lockStringToTopics      sync.RWMutex
	lockToJson              sync.RWMutex
}

// ByteToStr calls ByteToStrFunc.
func (mock *BlogUtilMock) ByteToStr(raw []byte) string {
	if mock.ByteToStrFunc == nil {
		panic("BlogUtilMock.ByteToStrFunc: method is nil but BlogUtil.ByteToStr was just called")
	}
	callInfo := struct {
		Raw []byte
	}{
		Raw: raw,
	}
	mock.lockByteToStr.Lock()
	mock.calls.ByteToStr = append(mock.calls.ByteToStr, callInfo)
	mock.lockByteToStr.Unlock()
	return mock.ByteToStrFunc(raw)
}

// ByteToStrCalls gets all the calls that were made to ByteToStr.
// Check the length with:
//
//	len(mockedBlogUtil.ByteToStrCalls())
func (mock *BlogUtilMock) ByteToStrCalls() []struct {
	Raw []byte
} {
	var calls []struct {
		Raw []byte
	}
	mock.lockByteToStr.RLock()
	calls = mock.calls.ByteToStr
	mock.lockByteToStr.RUnlock()
	return calls
}

// GetLimitAndOffset calls GetLimitAndOffsetFunc.
func (mock *BlogUtilMock) GetLimitAndOffset(page int) (int, int) {
	if mock.GetLimitAndOffsetFunc == nil {
		panic("BlogUtilMock.GetLimitAndOffsetFunc: method is nil but BlogUtil.GetLimitAndOffset was just called")
	}
	callInfo := struct {
		Page int
	}{
		Page: page,
	}
	mock.lockGetLimitAndOffset.Lock()
	mock.calls.GetLimitAndOffset = append(mock.calls.GetLimitAndOffset, callInfo)
	mock.lockGetLimitAndOffset.Unlock()
	return mock.GetLimitAndOffsetFunc(page)
}

// GetLimitAndOffsetCalls gets all the calls that were made to GetLimitAndOffset.
// Check the length with:
//
//	len(mockedBlogUtil.GetLimitAndOffsetCalls())
func (mock *BlogUtilMock) GetLimitAndOffsetCalls() []struct {
	Page int
} {
	var calls []struct {
		Page int
	}
	mock.lockGetLimitAndOffset.RLock()
	calls = mock.calls.GetLimitAndOffset
	mock.lockGetLimitAndOffset.RUnlock()
	return calls
}

// Int64ToString calls Int64ToStringFunc.
func (mock *BlogUtilMock) Int64ToString(raw int64) string {
	if mock.Int64ToStringFunc == nil {
		panic("BlogUtilMock.Int64ToStringFunc: method is nil but BlogUtil.Int64ToString was just called")
	}
	callInfo := struct {
		Raw int64
	}{
		Raw: raw,
	}
	mock.lockInt64ToString.Lock()
	mock.calls.Int64ToString = append(mock.calls.Int64ToString, callInfo)
	mock.lockInt64ToString.Unlock()
	return mock.Int64ToStringFunc(raw)
}

// Int64ToStringCalls gets all the calls that were made to Int64ToString.
// Check the length with:
//
//	len(mockedBlogUtil.Int64ToStringCalls())
func (mock *BlogUtilMock) Int64ToStringCalls() []struct {
	Raw int64
} {
	var calls []struct {
		Raw int64
	}
	mock.lockInt64ToString.RLock()
	calls = mock.calls.Int64ToString
	mock.lockInt64ToString.RUnlock()
	return calls
}

// IntToString calls IntToStringFunc.
func (mock *BlogUtilMock) IntToString(raw int) string {
	if mock.IntToStringFunc == nil {
		panic("BlogUtilMock.IntToStringFunc: method is nil but BlogUtil.IntToString was just called")
	}
	callInfo := struct {
		Raw int
	}{
		Raw: raw,
	}
	mock.lockIntToString.Lock()
	mock.calls.IntToString = append(mock.calls.IntToString, callInfo)
	mock.lockIntToString.Unlock()
	return mock.IntToStringFunc(raw)
}

// IntToStringCalls gets all the calls that were made to IntToString.
// Check the length with:
//
//	len(mockedBlogUtil.IntToStringCalls())
func (mock *BlogUtilMock) IntToStringCalls() []struct {
	Raw int
} {
	var calls []struct {
		Raw int
	}
	mock.lockIntToString.RLock()
	calls = mock.calls.IntToString
	mock.lockIntToString.RUnlock()
	return calls
}

// StringToArrayNews calls StringToArrayNewsFunc.
func (mock *BlogUtilMock) StringToArrayNews(jsonStr string) []domain.News {
	if mock.StringToArrayNewsFunc == nil {
		panic("BlogUtilMock.StringToArrayNewsFunc: method is nil but BlogUtil.StringToArrayNews was just called")
	}
	callInfo := struct {
		JsonStr string
	}{
		JsonStr: jsonStr,
	}
	mock.lockStringToArrayNews.Lock()
	mock.calls.StringToArrayNews = append(mock.calls.StringToArrayNews, callInfo)
	mock.lockStringToArrayNews.Unlock()
	return mock.StringToArrayNewsFunc(jsonStr)
}

// StringToArrayNewsCalls gets all the calls that were made to StringToArrayNews.
// Check the length with:
//
//	len(mockedBlogUtil.StringToArrayNewsCalls())
func (mock *BlogUtilMock) StringToArrayNewsCalls() []struct {
	JsonStr string
} {
	var calls []struct {
		JsonStr string
	}
	mock.lockStringToArrayNews.RLock()
	calls = mock.calls.StringToArrayNews
	mock.lockStringToArrayNews.RUnlock()
	return calls
}

// StringToArrayTopics calls StringToArrayTopicsFunc.
func (mock *BlogUtilMock) StringToArrayTopics(jsonStr string) []domain.Topics {
	if mock.StringToArrayTopicsFunc == nil {
		panic("BlogUtilMock.StringToArrayTopicsFunc: method is nil but BlogUtil.StringToArrayTopics was just called")
	}
	callInfo := struct {
		JsonStr string
	}{
		JsonStr: jsonStr,
	}
	mock.lockStringToArrayTopics.Lock()
	mock.calls.StringToArrayTopics = append(mock.calls.StringToArrayTopics, callInfo)
	mock.lockStringToArrayTopics.Unlock()
	return mock.StringToArrayTopicsFunc(jsonStr)
}

// StringToArrayTopicsCalls gets all the calls that were made to StringToArrayTopics.
// Check the length with:
//
//	len(mockedBlogUtil.StringToArrayTopicsCalls())
func (mock *BlogUtilMock) StringToArrayTopicsCalls() []struct {
	JsonStr string
} {
	var calls []struct {
		JsonStr string
	}
	mock.lockStringToArrayTopics.RLock()
	calls = mock.calls.StringToArrayTopics
	mock.lockStringToArrayTopics.RUnlock()
	return calls
}

// StringToInt calls StringToIntFunc.
func (mock *BlogUtilMock) StringToInt(raw string) (int, error) {
	if mock.StringToIntFunc == nil {
		panic("BlogUtilMock.StringToIntFunc: method is nil but BlogUtil.StringToInt was just called")
	}
	callInfo := struct {
		Raw string
	}{
		Raw: raw,
	}
	mock.lockStringToInt.Lock()
	mock.calls.StringToInt = append(mock.calls.StringToInt, callInfo)
	mock.lockStringToInt.Unlock()
	return mock.StringToIntFunc(raw)
}

// StringToIntCalls gets all the calls that were made to StringToInt.
// Check the length with:
//
//	len(mockedBlogUtil.StringToIntCalls())
func (mock *BlogUtilMock) StringToIntCalls() []struct {
	Raw string
} {
	var calls []struct {
		Raw string
	}
	mock.lockStringToInt.RLock()
	calls = mock.calls.StringToInt
	mock.lockStringToInt.RUnlock()
	return calls
}

// StringToInt64 calls StringToInt64Func.
func (mock *BlogUtilMock) StringToInt64(raw string) (int64, error) {
	if mock.StringToInt64Func == nil {
		panic("BlogUtilMock.StringToInt64Func: method is nil but BlogUtil.StringToInt64 was just called")
	}
	callInfo := struct {
		Raw string
	}{
		Raw: raw,
	}
	mock.lockStringToInt64.Lock()
	mock.calls.StringToInt64 = append(mock.calls.StringToInt64, callInfo)
	mock.lockStringToInt64.Unlock()
	return mock.StringToInt64Func(raw)
}

// StringToInt64Calls gets all the calls that were made to StringToInt64.
// Check the length with:
//
//	len(mockedBlogUtil.StringToInt64Calls())
func (mock *BlogUtilMock) StringToInt64Calls() []struct {
	Raw string
} {
	var calls []struct {
		Raw string
	}
	mock.lockStringToInt64.RLock()
	calls = mock.calls.StringToInt64
	mock.lockStringToInt64.RUnlock()
	return calls
}

// StringToNews calls StringToNewsFunc.
func (mock *BlogUtilMock) StringToNews(jsonStr string) domain.News {
	if mock.StringToNewsFunc == nil {
		panic("BlogUtilMock.StringToNewsFunc: method is nil but BlogUtil.StringToNews was just called")
	}
	callInfo := struct {
		JsonStr string
	}{
		JsonStr: jsonStr,
	}
	mock.lockStringToNews.Lock()
	mock.calls.StringToNews = append(mock.calls.StringToNews, callInfo)
	mock.lockStringToNews.Unlock()
	return mock.StringToNewsFunc(jsonStr)
}

// StringToNewsCalls gets all the calls that were made to StringToNews.
// Check the length with:
//
//	len(mockedBlogUtil.StringToNewsCalls())
func (mock *BlogUtilMock) StringToNewsCalls() []struct {
	JsonStr string
} {
	var calls []struct {
		JsonStr string
	}
	mock.lockStringToNews.RLock()
	calls = mock.calls.StringToNews
	mock.lockStringToNews.RUnlock()
	return calls
}

// StringToTopics calls StringToTopicsFunc.
func (mock *BlogUtilMock) StringToTopics(jsonStr string) domain.Topics {
	if mock.StringToTopicsFunc == nil {
		panic("BlogUtilMock.StringToTopicsFunc: method is nil but BlogUtil.StringToTopics was just called")
	}
	callInfo := struct {
		JsonStr string
	}{
		JsonStr: jsonStr,
	}
	mock.lockStringToTopics.Lock()
	mock.calls.StringToTopics = append(mock.calls.StringToTopics, callInfo)
	mock.lockStringToTopics.Unlock()
	return mock.StringToTopicsFunc(jsonStr)
}

// StringToTopicsCalls gets all the calls that were made to StringToTopics.
// Check the length with:
//
//	len(mockedBlogUtil.StringToTopicsCalls())
func (mock *BlogUtilMock) StringToTopicsCalls() []struct {
	JsonStr string
} {
	var calls []struct {
		JsonStr string
	}
	mock.lockStringToTopics.RLock()
	calls = mock.calls.StringToTopics
	mock.lockStringToTopics.RUnlock()
	return calls
}

// ToJson calls ToJsonFunc.
func (mock *BlogUtilMock) ToJson(raw interface{}) []byte {
	if mock.ToJsonFunc == nil {
		panic("BlogUtilMock.ToJsonFunc: method is nil but BlogUtil.ToJson was just called")
	}
	callInfo := struct {
		Raw interface{}
	}{
		Raw: raw,
	}
	mock.lockToJson.Lock()
	mock.calls.ToJson = append(mock.calls.ToJson, callInfo)
	mock.lockToJson.Unlock()
	return mock.ToJsonFunc(raw)
}

// ToJsonCalls gets all the calls that were made to ToJson.
// Check the length with:
//
//	len(mockedBlogUtil.ToJsonCalls())
func (mock *BlogUtilMock) ToJsonCalls() []struct {
	Raw interface{}
} {
	var calls []struct {
		Raw interface{}
	}
	mock.lockToJson.RLock()
	calls = mock.calls.ToJson
	mock.lockToJson.RUnlock()
	return calls
}
